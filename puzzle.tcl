# Define classes for shiftmerge puzzles
package require Tcl 8.6

if {[sourced_before PUZZLE]} {return}

source [file join $::smdir util.tcl]

# Puzzle is the base class for the shiftmerge puzzle modes.
# All state is contained in a square array of elements.
# Subclasses provide move methods to receive events and call this class'
# unexported Update_cells method to change the state of the game.

# The default size of the array is 4x4, but by passing the -size option
# when the instance is created, you can specify the length of a side,
# but it must be a value between 3 & 6 inclusive.

# The contents of the array will be integers 0 .. (size**2 - 1).
# The subclasses may interpret these integers as they wish EXCEPT that 0
# must always be interpreted as EMPTY. So double (the subclass that implements
# a game similar to 2048), may interpret values > 0 as 2**value. Others
# may simply have an array to map them to what they desire.

# An initial value for cells can be given with -cells, which expects
# a string generated by the classmethod cellstr. If you give both -size
# and -cells then they must agree on size. If you give just cells,
# then that sets the size.
oo::class create ::puzzle {

  classvar Default_size 4
  classvar Valid_size {3 4 5 6}

  # Return a string suitable for load method or -cells argument to
  # constructor. Usage:
  #
  # puzzle cellstr ?-size size? {?{row col val} ...?}
  # If size isn't provided, defaults to Default_Size. If it is provided,
  # an error is raised if isn't in Valid_size. Each triple sets the value
  # held by the cell at row & col (both zero based) to val. Val must be
  # an integer in the range 0 .. (size*size)-1 and row & col must be in
  # the range 0 .. size-1. Any cell not referred to in the list will be
  # set to 0 (EMPTY).
  classmethod cellstr args {
    set acnt [llength args]
    if {$acnt ni {1 3}} {
      set call [join [lrange [info level 0] 0 1] " "]
      set msgpfx "wrong # args: should be"
      error "$msgpfx \"$call ?-size s? {{row col val} ...}"
    }

    set size $Default_size
    if {$acnt == 3} {
      set s [lindex $args 1]
      if {$s ni $Valid_size} {
        error "bad size: must be in {$Valid_size}"
      }
      set size $s
    }

    set strlen [expr {$size * $size}]
    set ret [lrepeat "\x00" $strlen]

    set triplist [lindex $args end]
    set cnt 0
    foreach trip $triplist {
      if {[llength $trip] != 3} {
        error "not a triple at index $cnt in cell set list"
      }
      lassign $trip row col val
      if {$row < 0 || $row >= $size} {
        error "row at index $cnt out of range: $row"
      }
      if {$col < 0 || $col >= $size} {
        error "col at index $cnt out of range: $col"
      }

      if {$val < 0 || $val >= $strlen} {
        error "val at index $cnt out of range: $val"
      }
      set strndx [expr {$row * $size + $col}]
      string replace $ret $strndx $strndx [format "%c" $val]
      incr cnt
    }

    return $ret
  } ;# End classmethod cellstr

  # Length of row or column
  variable size
  variable numcells

  # Hold elements. A string of length size**2, with all characters
  # in the ASCII range and in particular their codepoints all < size**2.
  # The cell in row r, col c (both zero based) is represented by the
  # character at index r * size + c. The codepoint of the character
  # is the element or \u0000 (NUL) for an empty cell.
  variable cells

  constructor args {
    classvar Default_size Valid_size

    set size $Default_size
    set cstr {}
    set size_arg 0

    foreach {opt val} $args {
      switch $opt {
        -cells {
          set cstr $val
        }

        -size {
          if {$val ni $Valid_size} {
            error "invalid size ($val); must be in {$Valid_size}"
          }
          set size $val
          set size_arg 1
        }
      }
    }

    if {$cstr ne {}} {
      foreach s $Valid_size {
        array set sqrlen [expr $s * $s] $s
      }
      set iclen [string length $cstr]
      if {! [info exists sqrlen($iclen)]} {
        error "bad -cells string length ($iclen)"
      }

      set inferred_size $sqrlen($iclen)
      if {$size_arg && $inferred_size != $size} {
          error "-cells and -size disagree on size"
      }

      set size $inferred_size
    } else {
      set numcells [expr {$size * $size}]
      set cstr [string repeat "\x0" $numcells]
    }

    Update_cells $cstr
  } ;# End constructor

  method cellndx {r c} {
    return [expr $r * $size + $c]
  }

  method cellval {ndx} {
    scan [string index $ndx] "%c"
  }

  # Coordinates subclasses and mixins
  method Update_cells {cstr} {
    set cells $cstr
  } ;# End method Update_cells

  method load {cstr} {
    my clear
    my Update_cells $cstr
  } ;# End method load

  method room {} {
    set emptycnt 0
    foreach v [scan $cells [string repeat "%c" $numcells]] {
      if {$v eq 0} {incr emptycnt}
    }
    set emptycnt
  } ;# End method room

  method clear {} {
    set cstr [string repeat "\x0" $numcells]

    my Update_cells $cstr
  } ;# End method clear

} ;# End oo::class create puzzle

source_done PUZZLE
